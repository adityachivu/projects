function [label] = custom_predict(X, model)
%This function is a custom predict function using model
%   structure generated by svmtrain from libsvm.
%
%

%   Useful constants.
m = size(X, 1);     %   Number of examples to predict.
n = size(X, 2);     %   Number of features.
k = model.nr_class; %   Number of output classes.

%   Initialise variables.
accumulator = zeros(k, k-1);
vote_counter = zeros(k, 1);
label = zeros(m ,1);

%   Organise support vectors based on input model.
SV = model.SVs;
alphas = model.sv_coef; % alpha(i) * y(i)
len = model.totalSV;
num_SV = model.nSV;

%   Make prediction.
for p = 1:m

kernelmatrix = zeros(size(alphas));
accumulator = zeros(k, k-1);
for i = 1:len

    kernelmatrix(i, :) = alphas(i, :) .* gaussianKernel(SV(i, :)', X(p, :)' ) model.Parameters(4);
    %   RBF Kernel do product between every SV and the unclassified point.
    
end

beg = 1;
en = 1;
for i = 1:k

    en = beg + num_SV(i) - 1;
    accumulator(i, :) = sum(kernelmatrix(beg:en, :)); 
    beg = en + 1;
    %   Summation of SVs multiplied by aplha for every class.
    
end
%
%   Format of accumulator variable (example: 4 classes):
%
%        +-+-+-+---------------------------------+
%        |1|1|1|                                 |
%        |v|v|v|  Summation of SVs from class 1  |
%        |2|3|4|                                 |
%        +-+-+-+---------------------------------+
%        |1|2|2|                                 |
%        |v|v|v|  Summation of SVs from class 2  |
%        |2|3|4|                                 |
%        +-+-+-+---------------------------------+
%        |1|2|3|                                 |
%        |v|v|v|  Summation of SVs from class 3  |
%        |3|3|4|                                 |
%        +-+-+-+---------------------------------+
%        |1|2|3|                                 |
%        |v|v|v|  Summation of SVs from class 4  |
%        |4|4|4|                                 |
%        +-+-+-+---------------------------------+
%    

vote_counter = zeros(k, 1);
for i = 1:k
    for j = (i+1):(k)    
        index = (i * (k - i/2 + 1/2)) + j - i - k;  % Formula for accessing corresponding rho of each classifier.
%       model.rho vector aligned in the order of binary problems:
%       1 vs 2, 1 vs 3, ..., 1 vs k, 2 vs 3, ..., 2 vs k, ..., k-1 vs k.
        
        decision = accumulator(i, j-1) + accumulator(j, i); + model.rho(index);
        if(decision > 0)
            vote_counter(i)++;
        else
            vote_counter(j)++;
        end        
    end    
end

vote_counter;
[~, label(p)] = max(vote_counter);
end
end
